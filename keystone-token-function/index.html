<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Keystone トークン機能 | HayStacker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="description" content="概要Keystone のトークンは、2つ以上の技術の層で構成される階層構造となっている。ペイロードは、いくつかのトランスポート形式でラップされており、一意性、ID、および認証コンテキストなどの属性を提供する。トランスポートフォーマットでは、伝送と検証に必要なパッケージを提供する。 Keystone で使用可能な認証ドライバとして、UUID、PKI、PKIZ、Fernet がある。（2018年11月">
<meta name="keywords" content="OpenStack">
<meta property="og:type" content="article">
<meta property="og:title" content="Keystone トークン機能">
<meta property="og:url" content="http://haystacker.net/keystone-token-function/index.html">
<meta property="og:site_name" content="HayStacker">
<meta property="og:description" content="概要Keystone のトークンは、2つ以上の技術の層で構成される階層構造となっている。ペイロードは、いくつかのトランスポート形式でラップされており、一意性、ID、および認証コンテキストなどの属性を提供する。トランスポートフォーマットでは、伝送と検証に必要なパッケージを提供する。 Keystone で使用可能な認証ドライバとして、UUID、PKI、PKIZ、Fernet がある。（2018年11月">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://haystacker.net/keystone-token-function//uuid-token-validation.png">
<meta property="og:image" content="http://haystacker.net/keystone-token-function//uuid-token-validation.png">
<meta property="og:image" content="http://haystacker.net/keystone-token-function//pki-token-validation.png">
<meta property="og:image" content="http://haystacker.net/keystone-token-function//pki-token-validation.png">
<meta property="og:image" content="http://haystacker.net/keystone-token-function//fernet-token-publish.png">
<meta property="og:image" content="http://haystacker.net/keystone-token-function//fernet-token-validation.png">
<meta property="og:image" content="http://haystacker.net/keystone-token-function//fernet-token-validation.png">
<meta property="og:image" content="http://haystacker.net/keystone-token-function//fernet-lotation-process.png">
<meta property="og:updated_time" content="2019-06-10T20:30:53.722Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Keystone トークン機能">
<meta name="twitter:description" content="概要Keystone のトークンは、2つ以上の技術の層で構成される階層構造となっている。ペイロードは、いくつかのトランスポート形式でラップされており、一意性、ID、および認証コンテキストなどの属性を提供する。トランスポートフォーマットでは、伝送と検証に必要なパッケージを提供する。 Keystone で使用可能な認証ドライバとして、UUID、PKI、PKIZ、Fernet がある。（2018年11月">
<meta name="twitter:image" content="http://haystacker.net/keystone-token-function//uuid-token-validation.png">
<meta name="twitter:creator" content="@jundo414">
  
    <link rel="alternative" href="/atom.xml" title="HayStacker" type="application/atom+xml">
  
  
    <link rel="icon" href="favicon.ico">
  
  <link href='//fonts.googleapis.com/css?family=Inconsolata' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/css/style.css">
  

  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">HayStacker</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        
          <a id="nav-search-btn" class="nav-icon" title="Search"></a>
        
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://haystacker.net"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-keystone-token-function" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/keystone-token-function/" class="article-date">
  <time datetime="2019-06-10T19:53:53.000Z" itemprop="datePublished">2019-06-11</time>
</a>

    

  </div>
  <div class="article-inner">
    

    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Keystone トークン機能
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <div class="article-sharing">
  <ul>
    <li>
      <a href="http://b.hatena.ne.jp/entry/http://haystacker.net/keystone-token-function/" class="hatena-bookmark-button" data-hatena-bookmark-layout="standard" title="このエントリーをはてなブックマークに追加"><img src="http://b.st-hatena.com/images/entry-button/button-only.gif" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" /></a><script type="text/javascript" src="http://b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script>
    </li>
    <li>
      <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://haystacker.net/keystone-token-function/" data-via="{{ theme.twitter }}" data-counturl="http://haystacker.net/keystone-token-function/" >Tweet</a>
    </li>
    <li>
      <div class="fb-like" data-send="false" data-layout="button_count" data-show-faces="false" data-font="verdana" data-href="http://haystacker.net/keystone-token-function/"></div>
    </li>
  </ul>
</div>

      
      
        
        <h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>Keystone のトークンは、2つ以上の技術の層で構成される階層構造となっている。<br>ペイロードは、いくつかのトランスポート形式でラップされており、一意性、ID、および認証コンテキストなどの属性を提供する。<br>トランスポートフォーマットでは、伝送と検証に必要なパッケージを提供する。</p>
<p>Keystone で使用可能な認証ドライバとして、UUID、PKI、PKIZ、Fernet がある。（2018年11月20日 時点）。<br>それぞれのメリット・デメリットについて以下に示す。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Keystone 認証ドライバ</th>
<th style="text-align:left">メリット</th>
<th style="text-align:left">デメリット</th>
<th style="text-align:left">備考</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">UUID</td>
<td style="text-align:left">- シンプルで最小のトークン形式<br>シンプルな OpenStack の環境をつくる場合には良い</td>
<td style="text-align:left">- 永続的にトークンを保持する必要がある<br>- トークンテーブルが大きくなるとパフォーマンスに影響が出る<br>- トークン検証にはメタデータを保持した keystone 等の認証サービスへの接続が必須<br>- マルチ OpenStack 環境には不向き</td>
<td style="text-align:left">Newton 以降、Keystone のデフォルトのトークンドライバが “UUID” から “fernet” に変更となる<br>- Rocky で削除予定</td>
</tr>
<tr>
<td style="text-align:left">PKI</td>
<td style="text-align:left">トークン検証として keystone への問い合わせは不要</td>
<td style="text-align:left">標準的な HTTP ヘッダーサイズより大きい<br>- 複雑な設定<br>- マルチ OpenStack 環境への適用は不可</td>
<td style="text-align:left">Ocata 以降、非推奨となる</td>
</tr>
<tr>
<td style="text-align:left">PKIZ</td>
<td style="text-align:left">トークン検証として keystone への問い合わせは不要<br>- 圧縮により PKI のトークンサイズよりは小さくなる</td>
<td style="text-align:left">標準的な HTTP ヘッダーサイズより大きい<br>- 複雑な設定<br>- マルチ OpenStack 環境への適用は不可</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">Fernet</td>
<td style="text-align:left">永続的にトークンを保持しないため、定期的にトークンを削除する cron ジョブは不要<br>- トークンサイズサイズが小さい<br>- マルチ DC 環境に最適</td>
<td style="text-align:left">失効イベント数に比例してトークン検証のレスポンス時間が増加</td>
<td style="text-align:left">Ocata 以降、デフォルトで使用される</td>
</tr>
</tbody>
</table>
<h1 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h1><p><strong>ペイロード</strong>: UUID4</p>
<p>Keystone がサポートする最もシンプルなトークン形式で、UUID トークンのデータは、一意のランダムに生成された <a href="https://docs.python.org/2/library/uuid.html#uuid.uuid4" target="_blank" rel="noopener">UUID4</a> 値のみで構成される。</p>
<pre><code>In [1]: import uuid

In [2]: payload = uuid.uuid4()

In [3]: payload
Out[3]: UUID(&apos;0b1e0002-31c8-482a-837f-e2842b2c3d92&apos;)

In [4]: print(payload)
0b1e0002-31c8-482a-837f-e2842b2c3d92
</code></pre><p><strong>書式</strong>: 16進数</p>
<p>これらのトークンは、その16進表記でパッケージ化される。</p>
<pre><code>In [5]: token = payload.hex

In [6]: token
Out[6]: &apos;0b1e000231c8482a837fe2842b2c3d92&apos;

In [7]: len(token)
Out[7]: 32
</code></pre><p>トークンは、<code>0b1e000231c8482a837fe2842b2c3d92</code> といった形式となる。<br>トークン自体に ID や認証コンテキストは含まないため、オンラインで Keystone を使用した検証を行う必要がある。<br>Pyystoneでは、発行された UUID トークンを ID および認証コンテキストとマッピングを行う。</p>
<h2 id="トークン生成フロー"><a href="#トークン生成フロー" class="headerlink" title="トークン生成フロー"></a>トークン生成フロー</h2><p>TBD.</p>
<h2 id="トークン検証フロー"><a href="#トークン検証フロー" class="headerlink" title="トークン検証フロー"></a>トークン検証フロー</h2><p><img src="/keystone-token-function//uuid-token-validation.png" width="100%"></p>
<h2 id="トークン失効フロー"><a href="#トークン失効フロー" class="headerlink" title="トークン失効フロー"></a>トークン失効フロー</h2><p><img src="/keystone-token-function//uuid-token-validation.png" width="100%"></p>
<h1 id="PKI-PKIZ"><a href="#PKI-PKIZ" class="headerlink" title="PKI/PKIZ"></a>PKI/PKIZ</h1><p>PKIトークンには、ユーザのカタログ情報が含まれており、クラウドの規模に比例して大きくなる可能性がある。<br>PKI と PKIZトークンはほぼ同じだが、PKIZ トークンは圧縮を行う点が大きく異なる。</p>
<p><strong>ペイロード</strong>: JSON</p>
<p>PKI/PKIZ トークンは、トークンのペイロードとして、オンラインでのトークン検証結果として生成される JSON 形式のデータが使用される。</p>
<pre><code>{
    &quot;token&quot;: {
        &quot;audit_ids&quot;: [
            &quot;YyobSaHcTNCu7seusdTtpQ&quot;
        ],
        &quot;catalog&quot;: [
            {
                &quot;endpoints&quot;: [
                    {
                        &quot;id&quot;: &quot;9a29eaf20f7942b6b9c96cfb0aa02a3e&quot;,
                        &quot;interface&quot;: &quot;admin&quot;,
                        &quot;region&quot;: null,
                        &quot;region_id&quot;: null,
                        &quot;url&quot;: &quot;http://104.239.163.215:35357/v3&quot;
                    },
                    {
                        &quot;id&quot;: &quot;d3233afd2b6041d4a39f8ac1233757fd&quot;,
                        &quot;interface&quot;: &quot;public&quot;,
                        &quot;region&quot;: null,
                        &quot;region_id&quot;: null,
                        &quot;url&quot;: &quot;http://104.239.163.215:35357/v3&quot;
                    }
                ],
                &quot;id&quot;: &quot;1b796e214f8140118108a7e4e4ca6e16&quot;,
                &quot;name&quot;: &quot;Keystone&quot;,
                &quot;type&quot;: &quot;identity&quot;
            }
        ],
        &quot;expires_at&quot;: &quot;2015-02-26T05:48:26.094098Z&quot;,
        &quot;extras&quot;: {},
        &quot;issued_at&quot;: &quot;2015-02-26T05:33:26.094127Z&quot;,
        &quot;methods&quot;: [
            &quot;password&quot;
        ],
        &quot;project&quot;: {
            &quot;domain&quot;: {
                &quot;id&quot;: &quot;default&quot;,
                &quot;name&quot;: &quot;Default&quot;
            },
            &quot;id&quot;: &quot;59002ce739f143bb8b2cc33caf98fcf9&quot;,
            &quot;name&quot;: &quot;admin&quot;
        },
        &quot;roles&quot;: [
            {
                &quot;id&quot;: &quot;360b177d8c2347ff95e0ac1615ba8fb6&quot;,
                &quot;name&quot;: &quot;admin&quot;
            }
        ],
        &quot;user&quot;: {
            &quot;domain&quot;: {
                &quot;id&quot;: &quot;default&quot;,
                &quot;name&quot;: &quot;Default&quot;
            },
            &quot;id&quot;: &quot;85a9af145ddb4d19a9544dfbeac5d1f0&quot;,
            &quot;name&quot;: &quot;admin&quot;
        }
    }
}
</code></pre><p><strong>書式</strong>: CMS + [zlib] + base64</p>
<p>JSON ペイロードは、最初に非対称キーを使用して署名され、<a href="http://en.wikipedia.org/wiki/Cryptographic_Message_Syntax" target="_blank" rel="noopener">暗号メッセージ構文で</a>ラップされる。</p>
<p>PKIZ トークンの場合、署名されたペイロードは <a href="http://www.zlib.net/" target="_blank" rel="noopener">zlib</a> を使用して圧縮され、その後、PKI トークンは base64でエンコードされ、次に任意の置換方式を使用して URL セーフにされる。<br>代わりに、PDKZ トークンは、<a href="https://docs.python.org/2/library/base64.html#base64.urlsafe_b64encode" target="_blank" rel="noopener">従来の置換スキーム</a>を使用して base64-URL エンコードされる。</p>
<p>最後に、PKI トークンには固定プレフィックスがありませんが、PKIZ トークンには明示的に PKIZ_ <code></code>というプレフィックスが付く。<br>最小の PKI トークンは以下のようになる。</p>
<pre><code>MIIE-gYJKoZIhvcNAQcCoIIE7zCCBOsCAQExDTALBglghkgBZQMEAgEwggNMBgkqhkiG9w0BBwGgggM9BIIDOXsidG9rZW4iOnsibWV0aG9kcyI6WyJwYXNzd29yZCJd
LCJyb2xlcyI6W3siaWQiOiIzNjBiMTc3ZDhjMjM0N2ZmOTVlMGFjMTYxNWJhOGZiNiIsIm5hbWUiOiJhZG1pbiJ9XSwiZXhwaXJlc19hdCI6IjIwMTUtMDItMjZUMDU6
NDg6MjYuMDk0MDk4WiIsInByb2plY3QiOnsiZG9tYWluIjp7ImlkIjoiZGVmYXVsdCIsIm5hbWUiOiJEZWZhdWx0In0sImlkIjoiNTkwMDJjZTczOWYxNDNiYjhiMmNj
MzNjYWY5OGZjZjkiLCJuYW1lIjoiYWRtaW4ifSwiY2F0YWxvZyI6W3siZW5kcG9pbnRzIjpbeyJyZWdpb25faWQiOm51bGwsInVybCI6Imh0dHA6Ly8xMDQuMjM5LjE2
My4yMTU6MzUzNTcvdjMiLCJyZWdpb24iOm51bGwsImludGVyZmFjZSI6ImFkbWluIiwiaWQiOiI5YTI5ZWFmMjBmNzk0MmI2YjljOTZjZmIwYWEwMmEzZSJ9LHsicmVn
aW9uX2lkIjpudWxsLCJ1cmwiOiJodHRwOi8vMTA0LjIzOS4xNjMuMjE1OjM1MzU3L3YzIiwicmVnaW9uIjpudWxsLCJpbnRlcmZhY2UiOiJwdWJsaWMiLCJpZCI6ImQz
MjMzYWZkMmI2MDQxZDRhMzlmOGFjMTIzMzc1N2ZkIn1dLCJ0eXBlIjoiaWRlbnRpdHkiLCJpZCI6IjFiNzk2ZTIxNGY4MTQwMTE4MTA4YTdlNGU0Y2E2ZTE2IiwibmFt
ZSI6IktleXN0b25lIn1dLCJleHRyYXMiOnt9LCJ1c2VyIjp7ImRvbWFpbiI6eyJpZCI6ImRlZmF1bHQiLCJuYW1lIjoiRGVmYXVsdCJ9LCJpZCI6Ijg1YTlhZjE0NWRk
YjRkMTlhOTU0NGRmYmVhYzVkMWYwIiwibmFtZSI6ImFkbWluIn0sImF1ZGl0X2lkcyI6WyJZeW9iU2FIY1ROQ3U3c2V1c2RUdHBRIl0sImlzc3VlZF9hdCI6IjIwMTUt
MDItMjZUMDU6MzM6MjYuMDk0MTI3WiJ9fTGCAYUwggGBAgEBMFwwVzELMAkGA1UEBhMCVVMxDjAMBgNVBAgMBVVuc2V0MQ4wDAYDVQQHDAVVbnNldDEOMAwGA1UECgwF
VW5zZXQxGDAWBgNVBAMMD3d3dy5leGFtcGxlLmNvbQIBATALBglghkgBZQMEAgEwDQYJKoZIhvcNAQEBBQAEggEAYJR+ETbjA4RpgToeRm0qh-zxRWyBL4RdN99hLHV6
foIpcr6uXMN-DaUJvGygPDi1wi-HAbpErJAe9iRHk4+8BUnX--jQRTaYhkg237eyjpYHU8Hgt8Ydn7Wdnn0hriXKt+RZBG-ZEnnP-MZ9V9GGJz-BoAMHx42uF5j6mlfV
vUxtJGSaZ2wPROkLIHAjrX-8zEo8YhtGQHi-rFvXOoP+w8TVb907R2WNsGs3LbFKRmDv-yev6pMnz+gQu8uImf2idd18hyEYdw8M9bgZc2YsGBiPSeIm-VhzH9qTX0e7
fK-chhAE+saIEbl5Mw0PzybhTyKHRzqtsW4HWFOlbE0yOA==
</code></pre><p>今回のケースでは 1,712 バイトとなっている。<br>一方、最小の PKIZ トークンは次のようになる。</p>
<pre><code>PKIZ_eJxtVcmSozgUvPMVc6_oKMBgm0Mf2IzBCIpVlm4sNiAEtssLy9eP7K6Jqo4YboCUysyX7-nXL_ZopmV7_-gger784oBtm-8VcnYnbNePwlODQj-xb6tZ1zX_qqu
BORqx6moVreq20nAATLUyh6rygFa1F65uG0sZeE0brKqqgKLZtuHvr01pKZ8YSo3fX5scpnxmKW0x2Us4OQPae3MpKhPWnZJzdWfKxZG-fi6uTQaDxm9s2TPAgEgwe10
i-9DkPWLOfkwpIJWMYq32LId4c7LgfN2-2p1c5zBhG50aW8I5bxxlHw0N3tdDtndoISh1qdtLm9gDiJMbMOwbIDgBBlpyIEZLQII7mNuJnTrDhgH2GmN1pmgRvCRgS7k
hSO82Oa_sjrY2ObFvaYf26ZUr_2ZgYojrEo683fPX78WmhOaw82MgITHtPCvhgWjzvpW2HLBwh4nX-kYgYENtmCd3BAX63IhgeMuYkUcmB4kbHsHxgb-8wlBuC0s5c3k
fzoxafpicCcPynIvy8WVkJwu5NTA56ZQ_9Xc1X27VpTutR2AwyQTILjFFDkzSxIxZgjmZvbh4lAQ8WXyBSd9AHb2XVjrhbkNw9ATctDnzhbOb4at0Tu2RkIC4HX3DHDF
BPIYhRXG1AHNKEUEy6hAPIJhw5Cju9toUXdpzGVTue_Fp1vnOzLuy04WiG56Ap3IbDn6zfoBY5V1iz34kjR4BjL4p-AQI4JkDd4HmJ4sn2hPsB9CZ-UOLDtdIfFVoKKF
zzeBL4hm_fAELDhgVQy07TwwpjkMmg9a-0cqsTIJnPdPXDqBDC7sXSraRP-y1V4UyJo8dcObKbfuNSBIex7YErISFqlpgI-CxUdYotmcQOy0mxeiJKYuwR5-s825z416
Otjd62Hs8KyH9OoketuGE9oAl8aa8fBHT6U8Sw0cONyzu9pKV_sz90cLodxsh3wZ_BSn8imupO8o3S6_GsSkxhjyaW55jNAVECtm37AUmlQQgK6eFJCAC-T-aP-v-J-I
bAVuUf1aP--rxNklGMekrIRM290g8NxnFt6yjJOmd3qavvpiLRUrx5u_O5H62JjDMH52JJMja-hhbuooSNoEsjU0iDWyGIZ1NF6itpQqJyWk10NMUjAZR2YjyUrYKaGl
6Z6bxIJAGQ0VGGgRbQ03TvPdoaZg-UIfXZr0aNlwK5Rnvg9EyVPgHAABjUS7KSaYHa3MrrJG6nffIA1tT_2c2ckbwc6CamhaoZlWZ6s5fHiM7FSN_F4LPwIZ62eK-Ck7
bCCpG5gpWk55VZuJb-wZ30-Uwfh6c4_0Srgp12Ak0si9usTwdmuUcuHlIuqUjXarRXcN-_THIn6tdAN-nPSg57PGwD4Wt2Avm6qpmghnW1w0ZrGUX7cQ3MprKmr7nWFm
kufamysNiZfWSqNPDabMl54Q7ykPw2Gzxx1G8gzcNvGvRvTCjTLAqtQ1dZ7xM-zxbbam8Vha3SgGNhxL8-bESItc8SiF3PhHSXD4Mfztp16N2Em_F8CYqviBlaj917zP
Uwf2h-1nsiVSIpWGKeu-Gdtc6rtfD2eRWEbn5VNhNU-wivHb8i14U1yo6RNH7qf0Y4ValpVTG9nR4NMHv39zrQjM94_ty-xc2_Erg
</code></pre><p>PKI と比較して、1,637 バイトと若干小さくなっている。<br>今回の場合、トークンには最小限のカタログ情報だけがエンコードされているが、カタログ情報の大きい PKIZ トークンでは、PKI と比較して圧縮率がはるかに高くなる。</p>
<h2 id="トークン生成フロー-1"><a href="#トークン生成フロー-1" class="headerlink" title="トークン生成フロー"></a>トークン生成フロー</h2><p>TBD.</p>
<h2 id="トークン検証フロー-1"><a href="#トークン検証フロー-1" class="headerlink" title="トークン検証フロー"></a>トークン検証フロー</h2><p><img src="/keystone-token-function//pki-token-validation.png" width="100%"></p>
<h2 id="トークン失効フロー-1"><a href="#トークン失効フロー-1" class="headerlink" title="トークン失効フロー"></a>トークン失効フロー</h2><p><img src="/keystone-token-function//pki-token-validation.png" width="100%"></p>
<h1 id="Fernet"><a href="#Fernet" class="headerlink" title="Fernet"></a>Fernet</h1><p>Fernet トークンはトークン内にアカウント情報（ユーザID、プロジェクトID）や有効期限を保持し、共通鍵で暗号化して格納している。<br>そのため Keystone のデータベース問い合わせすることなくトークンの検証が可能となっており、データベース負荷を大幅に低減することが可能となる。</p>
<p>Fornet トークンでは、memcached の使用が推奨されている。<br>トークンを定期的に削除する cron ジョブは不要となる。<br>Newton 以降、Keystone のデフォルトのトークンドライバが “UUID” から “fernet” に変更となる。</p>
<p><strong>ペイロード: Fernet トークン</strong></p>
<p>Fernet トークンは、最小の識別情報と動的な認証コンテキストを優先する非常に軽いトークン。</p>
<p><strong>書式: Fernet</strong></p>
<p>Keystone の Fernet トークン形式は、暗号化認証の機構である Fernet がベースとなっている。<br>Fernet は、もともと Heroku が API トークンで使用するために作成された安全なメッセージング形式で、共通鍵暗号化を実装したもの。</p>
<p>共通鍵暗号とは、暗号用と復号用に同じ鍵を用いる方式で、ファイル暗号などによく使われ、処理が早いのが特徴。 共通鍵暗号では、暗号化されたデータを復号化する前に鍵を渡す必要がある。</p>
<p>Fernet 認証方式では、共通鍵の一覧を取得し、一覧内にある最初の鍵を使用してすべての暗号化を実行し、その一覧からすべての鍵を使用して復号化を試みるといった複数の鍵にも対応している。</p>
<p>Fernet 鍵は base64 エンコーディング（base64.urlsafe_b64encode）で、次の項目の組み合わせで構成されている。</p>
<table>
<thead>
<tr>
<th style="text-align:left">項目</th>
<th style="text-align:left">データ長</th>
<th style="text-align:left">値</th>
<th style="text-align:left">備考</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Fernet 形式のバージョン番号 (Version)</td>
<td style="text-align:left">8ビット</td>
<td style="text-align:left">0x80</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">現在のタイムスタンプ (Timestamp)</td>
<td style="text-align:left">64ビット</td>
<td style="text-align:left">int(time.time())</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">初期化ベクトル (IV)</td>
<td style="text-align:left">128ビット</td>
<td style="text-align:left">os.urandom(16)</td>
<td style="text-align:left">- 署名鍵はfernet鍵の最初の16バイト<br>- 暗号化キーは fernet キーの最後の16バイト</td>
</tr>
<tr>
<td style="text-align:left">暗号文 (Ciphertext)</td>
<td style="text-align:left">可変長（128 ビットの倍数）</td>
<td style="text-align:left"></td>
<td style="text-align:left">以下のデータにより構成されている。<br>- <strong>バージョン</strong>:<br>&nbsp;&nbsp;0（スコープなしのペイロード）<br>&nbsp;&nbsp;1（ドメインスコープのペイロード）<br>&nbsp;&nbsp;2（プロジェクトスコープのペイロード）<br>&nbsp;&nbsp;3（トラストスコープのペイロード）<br>- <strong>ユーザID</strong>: バイト形式<br>- <strong>メソッド</strong>: 整数形式<br>- <strong>プロジェクトID</strong>: バイト形式<br>- <strong>有効期限</strong>: タイムスタンプの整数形式<br>- <strong>監査ID</strong>: バイト形式</td>
</tr>
<tr>
<td style="text-align:left">HMAC</td>
<td style="text-align:left">256 ビット</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>Fernet は、トークンの作成時間をトークンから把握することもできる。</p>
<pre><code>&gt;&gt;&gt; token = b&apos;gAAAAABb93HyEo0JIFZlTfKHlyRFTiJPqlBK75MEt_858fnATWN3mRNomlNQr-ZjHwnmlzcXKKZYpuGSmc8UgMwwEhCvWk5PsCiAxV-GsVDhpYcduZVK6ugtLTVkGgZZiEBC3-77Jkpi8VA2qouzyWzDbBgjMO98YuQkjEH6kPAKApGYrSGnFEw=&apos;
&gt;&gt;&gt; 
&gt;&gt;&gt; import struct, base64, datetime
&gt;&gt;&gt; timestamp = struct.unpack(&apos;&gt;Q&apos;, base64.urlsafe_b64decode(token)[1:9])[0]
&gt;&gt;&gt; 
&gt;&gt;&gt; timestamp
1542943218
&gt;&gt;&gt; datetime.datetime.fromtimestamp(timestamp).strftime(&apos;%Y-%m-%d %H:%M:%S&apos;)
&apos;2018-11-23 12:20:18&apos;
</code></pre><h2 id="トークン生成フロー-2"><a href="#トークン生成フロー-2" class="headerlink" title="トークン生成フロー"></a>トークン生成フロー</h2><p><img src="/keystone-token-function//fernet-token-publish.png" width="100%"></p>
<h2 id="Fernet-トークンのバージョン"><a href="#Fernet-トークンのバージョン" class="headerlink" title="Fernet トークンのバージョン"></a>Fernet トークンのバージョン</h2><p>Fernet 形式のバージョン。現在は “0x80” で固定。</p>
<pre><code>&gt;&gt;&gt; version=b&apos;\x80&apos;
</code></pre><h2 id="現在時刻のタイムスタンプ"><a href="#現在時刻のタイムスタンプ" class="headerlink" title="現在時刻のタイムスタンプ"></a>現在時刻のタイムスタンプ</h2><p>現在時刻を取得する。</p>
<pre><code>&gt;&gt;&gt; import time
&gt;&gt;&gt; time.time()
1542943218.944182
</code></pre><p>現在時刻を int 型へ変換する。</p>
<pre><code>&gt;&gt;&gt; current_time=int(time.time())
&gt;&gt;&gt; current_time
1542943218
</code></pre><h2 id="IV"><a href="#IV" class="headerlink" title="IV"></a>IV</h2><p>初期化ベクトルを作成する。</p>
<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; iv = os.urandom(16)
&gt;&gt;&gt; iv
b&apos;\x12\x8d\t VeM\xf2\x87\x97$EN&quot;O\xaa&apos;
</code></pre><h2 id="暗号文"><a href="#暗号文" class="headerlink" title="暗号文"></a>暗号文</h2><pre><code>&gt;&gt;&gt; from cryptography.hazmat.primitives import hashes, padding
&gt;&gt;&gt; from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
&gt;&gt;&gt; from cryptography.hazmat.backends import default_backend
&gt;&gt;&gt; 
&gt;&gt;&gt; padder = padding.PKCS7(algorithms.AES.block_size).padder()
</code></pre><p>padder にブロックサイズ 128 が設定される。</p>
<pre><code>&gt;&gt;&gt; padder.__dict__
{&apos;_buffer&apos;: b&apos;&apos;, &apos;block_size&apos;: 128}
</code></pre><p>プロジェクトスコープ付きペイロードを定義する。</p>
<pre><code>&gt;&gt;&gt; project_scoped_payload = b&apos;\x96\x02\xb0\x134\xf3\xed~\xb2H;\x91\xb8\x19+\xa0C\xb5\x80\x02\xb0B=E\xcd\xde\xc8Ap\xbe6^\x0b1\xa1\xb1_\xcbA\xd5\x87P\x02\xb4C\xd9\x91\xb0}oA\xd3fCu\x95z\\\xbd\xd8{\x89\xbc&apos;
</code></pre><p>ブロックサイズに合わせてパディングを適用する。</p>
<pre><code>&gt;&gt;&gt; padded_data = padder.update(project_scoped_payload) + padder.finalize()
&gt;&gt;&gt; padded_data
b&apos;\x96\x02\xb0\x134\xf3\xed~\xb2H;\x91\xb8\x19+\xa0C\xb5\x80\x02\xb0B=E\xcd\xde\xc8Ap\xbe6^\x0b1\xa1\xb1_\xcbA\xd5\x87P\x02\xb4C\xd9\x91\xb0}oA\xd3fCu\x95z\\\xbd\xd8{\x89\xbc\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10&apos;
</code></pre><p>32バイトのランダム文字列バイナリ形式の fernet 鍵を定義する。</p>
<pre><code>&gt;&gt;&gt; b_key = os.urandom(32)
</code></pre><p>暗号化キーは fernet キーの最後の16バイトとなる。</p>
<pre><code>&gt;&gt;&gt; backend = default_backend()
&gt;&gt;&gt; e_key = b_key[16:]
</code></pre><p>CBC モードで ABC 暗号化を行う。</p>
<pre><code>&gt;&gt;&gt; encryptor = Cipher(algorithms.AES(e_key), modes.CBC(iv), backend).encryptor()
</code></pre><p>パディングされた Keystone ペイロードを暗号化する。</p>
<pre><code>&gt;&gt;&gt; ciphertext = encryptor.update(padded_data) + encryptor.finalize()
&gt;&gt;&gt; ciphertext
b&apos;PJ\xef\x93\x04\xb7\xff9\xf1\xf9\xc0Mcw\x99\x13h\x9aSP\xaf\xe6c\x1f\t\xe6\x977\x17(\xa6X\xa6\xe1\x92\x99\xcf\x14\x80\xcc0\x12\x10\xafZNO\xb0(\x80\xc5_\x86\xb1P\xe1\xa5\x87\x1d\xb9\x95J\xea\xe8--5d\x1a\x06Y\x88@B\xdf\xee\xfbJb&apos;
</code></pre><h2 id="HMAC"><a href="#HMAC" class="headerlink" title="HMAC"></a>HMAC</h2><p>署名鍵付き 256 ビット SHA256 HMAC。 上記のすべての項目（バージョン、タイムスタンプ、IV、暗号文）を結合したもの。</p>
<p>署名鍵はfernet鍵の最初の16バイトとなる。</p>
<pre><code>&gt;&gt;&gt; s_key = b_key[:16]
</code></pre><p>HMAC の作成では SHA256 ハッシュを使用する。</p>
<pre><code>&gt;&gt;&gt; from cryptography.hazmat.primitives.hmac import HMAC
&gt;&gt;&gt; h = HMAC(s_key, hashes.SHA256(), backend)
</code></pre><p>HMAC は Fernet Version、Timestamp、IV、Ciphertext の組み合わせで構成される。</p>
<pre><code>&gt;&gt;&gt; import struct
&gt;&gt;&gt; 
&gt;&gt;&gt; basic_parts = (version+ struct.pack(&quot;&gt;Q&quot;, current_time) + iv + ciphertext)
&gt;&gt;&gt; basic_parts
b&apos;\x80\x00\x00\x00\x00[\xf7q\xf2\x12\x8d\t VeM\xf2\x87\x97$EN&quot;O\xaaPJ\xef\x93\x04\xb7\xff9\xf1\xf9\xc0Mcw\x99\x13h\x9aSP\xaf\xe6c\x1f\t\xe6\x977\x17(\xa6X\xa6\xe1\x92\x99\xcf\x14\x80\xcc0\x12\x10\xafZNO\xb0(\x80\xc5_\x86\xb1P\xe1\xa5\x87\x1d\xb9\x95J\xea\xe8--5d\x1a\x06Y\x88@B\xdf\xee\xfbJb&apos;
</code></pre><blockquote>
<p>“&gt;” はビッグエンディアン、“Q” は符号なし long long 型を表す。</p>
</blockquote>
<p>Fernet Version、Timestamp、IV、Ciphertext から HMAC を生成する。</p>
<pre><code>&gt;&gt;&gt; h.update(basic_parts)
&gt;&gt;&gt; hmac = h.finalize()
&gt;&gt;&gt; hmac
b&apos;\xf1P6\xaa\x8b\xb3\xc9l\xc3l\x18#0\xef|b\xe4$\x8cA\xfa\x90\xf0\n\x02\x91\x98\xad!\xa7\x14L&apos;
</code></pre><p>Fernet トークンは、Version、Timestamp、IV、Ciphertext、HMAC の Base64 URL-Safe エンコーディングとなる。</p>
<pre><code>&gt;&gt;&gt; import base64
&gt;&gt;&gt; 
&gt;&gt;&gt; fernet = base64.urlsafe_b64encode(basic_parts + hmac).decode(&apos;utf-8&apos;)
&gt;&gt;&gt; fernet
&apos;gAAAAABb93HyEo0JIFZlTfKHlyRFTiJPqlBK75MEt_858fnATWN3mRNomlNQr-ZjHwnmlzcXKKZYpuGSmc8UgMwwEhCvWk5PsCiAxV-GsVDhpYcduZVK6ugtLTVkGgZZiEBC3-77Jkpi8VA2qouzyWzDbBgjMO98YuQkjEH6kPAKApGYrSGnFEw=&apos;
</code></pre><h2 id="トークン検証フロー-2"><a href="#トークン検証フロー-2" class="headerlink" title="トークン検証フロー"></a>トークン検証フロー</h2><p><img src="/keystone-token-function//fernet-token-validation.png" width="100%"></p>
<h2 id="トークン失効フロー-2"><a href="#トークン失効フロー-2" class="headerlink" title="トークン失効フロー"></a>トークン失効フロー</h2><p><img src="/keystone-token-function//fernet-token-validation.png" width="100%"></p>
<h2 id="Keystone-における-Fernet-トークン設定"><a href="#Keystone-における-Fernet-トークン設定" class="headerlink" title="Keystone における Fernet トークン設定"></a>Keystone における Fernet トークン設定</h2><p>Fernet トークンを使用するには、keystone.conf の [fernet_token] セクション項目、および [token] セクションの provider 項目を設定する。</p>
<pre><code>[token]
provider = keystone.token.providers.fernet.Provider

[fernet_tokens]
# Fernet 鍵を保存する鍵リポジトリの場所
key_repository = /etc/keystone/fernet-keys/

# 鍵リポジトリ上の最大の鍵の数（初期値: 3）
# - コントローラノードの台数以下を設定する。
max_active_keys = 5
</code></pre><p>Fernet 鍵は、デフォルトで “/etc/keystone/fernet-keys/” にある鍵リポジトリに保存されている。</p>
<p>Fernet 鍵ファイルは 0 から始まる integer 形式の名前となる。</p>
<pre><code>$ ls /etc/keystone/fernet-keys
0 1 2 3 4
</code></pre><p>以下の 3 つのタイプの鍵ファイルが存在する。</p>
<ul>
<li><strong>プライマリ鍵</strong> - プライマリ鍵は、fernet トークンの暗号化および復号化に使用される。最も大きいインデックス名となっているものがプライマリ鍵ファイルとなる。</li>
<li><strong>セカンダリ鍵</strong> - セカンダリ鍵は、fernet トークンの復号にのみ使用される。 セカンダリ鍵ファイルの名前は、最大のインデックスより小さく、最小のインデックス（0）よりも大きい値となる。</li>
<li><strong>ステージ鍵</strong> - ステージング鍵は、fernet トークンの復号にのみ使用されるセカンダリ鍵と似ているが、最小のインデックス番号（0）となっているものがステージング鍵となる。</li>
</ul>
<p>Fernet 鍵は、以下のフローで遷移する。</p>
<ul>
<li>新規作成 → ステージ鍵 → プライマリ鍵 → セカンダリ鍵 → 削除</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">Fernet 鍵</th>
<th style="text-align:left">インデックス番号<br>（max_active_keys=3 の場合）</th>
<th style="text-align:left">暗号化</th>
<th style="text-align:left">複合化</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">プライマリ鍵</td>
<td style="text-align:left">2</td>
<td style="text-align:left">○</td>
<td style="text-align:left">○</td>
</tr>
<tr>
<td style="text-align:left">セカンダリ鍵</td>
<td style="text-align:left">1</td>
<td style="text-align:left">-</td>
<td style="text-align:left">○</td>
</tr>
<tr>
<td style="text-align:left">ステージ鍵</td>
<td style="text-align:left">0</td>
<td style="text-align:left">-</td>
<td style="text-align:left">○</td>
</tr>
</tbody>
</table>
<p>要約すると、fernet トークンはプライマリ鍵を使用して暗号化され、鍵リポジトリからの fernet キーの一覧を使用して復号化される。</p>
<h2 id="Fernet-鍵のローテーション手順"><a href="#Fernet-鍵のローテーション手順" class="headerlink" title="Fernet 鍵のローテーション手順"></a>Fernet 鍵のローテーション手順</h2><p><img src="/keystone-token-function//fernet-lotation-process.png" width="100%"></p>
<p>keystone-manage コマンドを使用し、鍵リポジトリに2つの鍵を新規作成する fernet-setup を行う。</p>
<p>セカンダリ鍵はなく、プライマリ鍵 1 と、ステージ鍵 0 とで構成される。</p>
<pre><code>$ keystone-manage fernet_setup
2507 INFO keystone.token.providers.fernet.utils [-] [fernet_tokens] key_repository does not appear to exist; attempting to create it
2507 INFO keystone.token.providers.fernet.utils [-] Created a new key: /etc/keystone/fernet-keys/0
2507 INFO keystone.token.providers.fernet.utils [-] Starting key rotation with 1 key files: [&apos;/etc/keystone/fernet-keys/0&apos;]
2507 INFO keystone.token.providers.fernet.utils [-] Current primary key is: 0
2507 INFO keystone.token.providers.fernet.utils [-] Next primary key will be: 1
2507 INFO keystone.token.providers.fernet.utils [-] Promoted key 0 to be the primary: 1
2507 INFO keystone.token.providers.fernet.utils [-] Created a new key: /etc/keystone/fernet-keys/0
2507 INFO keystone.token.providers.fernet.utils [-] Excess keys to purge: []
$ ls /etc/keystone/fernet-keys/
0  1
</code></pre><p>ローテーションの状態を確認しながら、ローテーションを行う。</p>
<pre><code>$ keystone-manage fernet_rotate
2528 INFO keystone.token.providers.fernet.utils [-] Starting key rotation with 2 key files: [&apos;/etc/keystone/fernet-keys/0&apos;, &apos;/etc/keystone/fernet-keys/1&apos;]
2528 INFO keystone.token.providers.fernet.utils [-] Current primary key is: 1
2528 INFO keystone.token.providers.fernet.utils [-] Next primary key will be: 2
2528 INFO keystone.token.providers.fernet.utils [-] Promoted key 0 to be the primary: 2
2528 INFO keystone.token.providers.fernet.utils [-] Created a new key: /etc/keystone/fernet-keys/0
2528 INFO keystone.token.providers.fernet.utils [-] Excess keys to purge: []
$ ls /etc/keystone/fernet-keys/
0  1  2
</code></pre><ul>
<li>ローテーションした後、2 がプライマリ鍵となり、0 および 1 は復号化で使用される。</li>
<li>前のプライマリ鍵 1 は、同じ名前のままセカンダリ鍵となる。</li>
<li>新しいステージ鍵 0 が導入される。</li>
</ul>
<p>再度 Fernet 鍵のローテーションを行う。</p>
<pre><code>$ keystone-manage fernet_rotate
2698 INFO keystone.token.providers.fernet.utils [-] Starting key rotation with 3 key files: [&apos;/etc/keystone/fernet-keys/0&apos;, &apos;/etc/keystone/fernet-keys/1&apos;, &apos;/etc/keystone/fernet-keys/2&apos;]
2698 INFO keystone.token.providers.fernet.utils [-] Current primary key is: 2
2698 INFO keystone.token.providers.fernet.utils [-] Next primary key will be: 3
2698 INFO keystone.token.providers.fernet.utils [-] Promoted key 0 to be the primary: 3
2698 INFO keystone.token.providers.fernet.utils [-] Created a new key: /etc/keystone/fernet-keys/0
2698 INFO keystone.token.providers.fernet.utils [-] Excess keys to purge: [1]
$ ls /etc/keystone/fernet-keys/
0  2  3
</code></pre><p>今度は、最大のインデックスは 3 となり、ステージ鍵 0 は、鍵 3 のプライマリ鍵となる。<br>前のプライマリ鍵 2 は、同じファイル名のままセカンダリ鍵となり、前のセカンダリ鍵は、同じファイル名のままセカンダリ鍵として残る。そして、新たにステージ鍵 0 が導入される。<br>max_active_keys を 3 に設定した場合、セカンダリ鍵 1 は今回の鍵のローテーション中に削除される。</p>
<p>想定通り、プライマリ鍵が 3 となり、鍵 1 が削除されている。</p>
<p>今回の場合、max_active_keys=3 で設定しているため、有効な鍵は 3 つとなっており、最も小さいインデックスの鍵が削除される。<br>鍵 2 と鍵 3 がプライマリ鍵のときに暗号化されたものは、引き続き検証可能な状態だが、削除済みである鍵 1 で暗号化されたものは検証することができない。<br>鍵のローテーションを頻繁に行ったり、max_active_keys の値が小さすぎたりした場合、有効なトークンが早期に消滅することがあり得るため、注意が必要となる。<br>たとえば、プライマリ鍵を 30 分ごとにローテーションするようにし、Keystone トークンの有効期間を 6 時間に設定している場合、max_active_keys には 12 以上の値を設定する必要がある。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">max_active_keys 設定値</span><br><span class="line">&gt;= Keystone トークン有効時間 / ローテーション間隔</span><br><span class="line">= 6 [時間 ] / 30 [分]</span><br><span class="line">= 360 [分] / 30 [分]</span><br><span class="line">= 12</span><br></pre></td></tr></table></figure>
<h2 id="性能比較"><a href="#性能比較" class="headerlink" title="性能比較"></a>性能比較</h2><p>トークンの作成速度は、PKI/PKIZ が一番遅く、次に UUID が続き、Fernet が一番早い。（2015年6月時点）</p>
<p>UUID は、Keystone で使用可能な最もシンプルなトークンフォーマットで、ランダムに生成された 32 文字の文字列を使用して Keystone に接続し、トークン検証を行う。<br>この時、Keystone でトークンが有効か無効化かを判断するために、トークンとユーザー ID、認証メタデータのマッピング情報を保持している必要がある。</p>
<p>PKI トークンは、所有者の ID とトークン認証コンテキストをトークンと共にパックし、CMS を使用してパッケージ全体をラップする。</p>
<p>PKIZ トークンは、端的に言うと PKI トークンを圧縮を追加したもの。</p>
<p>近年では、A​​ES-CBC を使用した暗号化、および SHA256 を使用した署名を行う Fernet トークンを使用することができるようになっている。</p>
<p>Fernet トークンには、所有者 ID や認証コンテキストに関するメタデータも含まれている。</p>
<p>Keystone で行う処理の内、性能が大きく影響するものとしては、主にトークン作成およびトークン検証が挙げられる。</p>
<p>その他の処理については、頻繁に行われるものでもなく、性能はさほど問題にはならない。</p>
<p>Keystone トークンを複数の地域にまたがった同期機能は、機能要求としてあるのが一般的となっている。<br>これは、2 つ以上の地域にそれぞれ Keystone インスタンスを立て、ある地域で生成されたトークンを他の地域で検証し、正常に使用できるようにするといったケースである。</p>
<p>UUID トークンを使用する場合には、可能な限り迅速にすべての地域にトークンを同期させる必要があり、複雑となる傾向がある。<br>この場合、クライアントからのトークンをすべての場所に複製するまで保留するか、ローカルで作成して非同期で複製するかの 2 つの方法が考えられる。<br>しかし、1つ目の方法では、トークンの作成時に応答時間が長くなり、2つ目の方法では、トークン発行が競合状態になる可能性がある。<br>つまり、どちらの方法を採択するにせよ応答時間の短縮が必須となってくる。</p>
<p>一方、Fernet トークンは永続化する必要がないため、token テーブルは空となり、すべての地域と同期を取る必要がない。</p>
<pre><code>&gt; SELECT * FROM `token`;
Empty set (0.00 sec)
</code></pre><p>世界中に点在するう5つのデータセンター（ワシントンDC、シカゴ [イリノイ州]、ダラス [テキサス州]、香港、シドニー [オーストラリア]）で Fernet 検証結果では、応答時間は1つの地域で行なった場合と変わらないにも関わらず、すべての地域で即座にトークンが使用可能となる。<br>待機時間や同期にかかる時間は一切なく、応答時間には同期レプリケーションのオーバーヘッドが発生しないため、すべての地域でトークンの暗号鍵をすぐに確認することができるようになる。<br>※ 今回、検証ケースを絞るため Fernet トークンは常に255バイト未満で設定。</p>
<h2 id="Keystone-グローバルネットワークでクラスタ化された-Galera-Cluster-構成"><a href="#Keystone-グローバルネットワークでクラスタ化された-Galera-Cluster-構成" class="headerlink" title="Keystone + グローバルネットワークでクラスタ化された Galera Cluster 構成"></a>Keystone + グローバルネットワークでクラスタ化された Galera Cluster 構成</h2><p>これらのメトリックは、公開されたインターネット上でレプリケーションを実行するグローバルに分散された5台のGalera クラスタノードの場合の検証結果を示している。</p>
<p><strong>トークン作成の性能</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">トークン</th>
<th style="text-align:left">応答時間</th>
<th style="text-align:left">リクエスト数/秒</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">UUID</td>
<td style="text-align:left">342.4</td>
<td style="text-align:left">166.9</td>
</tr>
<tr>
<td style="text-align:left">PKI</td>
<td style="text-align:left">351.4</td>
<td style="text-align:left">110.2</td>
</tr>
<tr>
<td style="text-align:left">PKIZ</td>
<td style="text-align:left">339.7</td>
<td style="text-align:left">120.7</td>
</tr>
<tr>
<td style="text-align:left">Fernet</td>
<td style="text-align:left">50.8</td>
<td style="text-align:left">237.1</td>
</tr>
</tbody>
</table>
<p><strong>トークン検証の性能</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">トークン</th>
<th style="text-align:left">応答時間</th>
<th style="text-align:left">リクエスト数/秒</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">UUID</td>
<td style="text-align:left">6.02</td>
<td style="text-align:left">1715.7</td>
</tr>
<tr>
<td style="text-align:left">PKI</td>
<td style="text-align:left">6.25</td>
<td style="text-align:left">1717.2</td>
</tr>
<tr>
<td style="text-align:left">PKIZ</td>
<td style="text-align:left">6.15</td>
<td style="text-align:left">1676.4</td>
</tr>
<tr>
<td style="text-align:left">Fernet</td>
<td style="text-align:left">5.55</td>
<td style="text-align:left">1957.8</td>
</tr>
</tbody>
</table>
<blockquote>
<p>※1 ApacheBench には最大要求サイズがあり、PKI または PKIZ トークンの ( X-Auth-Token + X-Subject-Token) がこれを超える。そのため、Stack Overflow での提案に沿って ApacheBench 最大要求サイズを広げた後、再コンパイルすることでこの制限を回避している。</p>
</blockquote>
<h1 id="参考URL"><a href="#参考URL" class="headerlink" title="参考URL"></a>参考URL</h1><ul>
<li><a href="https://developer.ibm.com/opentech/2015/11/11/deep-dive-keystone-fernet-tokens/" target="_blank" rel="noopener">https://developer.ibm.com/opentech/2015/11/11/deep-dive-keystone-fernet-tokens/</a></li>
<li><a href="https://blog.dolphm.com/the-anatomy-of-openstack-keystone-token-formats/" target="_blank" rel="noopener">https://blog.dolphm.com/the-anatomy-of-openstack-keystone-token-formats/</a></li>
<li><a href="https://www.slideshare.net/priti_desai/deep-dive-into-keystone-tokens-and-lessons-learned" target="_blank" rel="noopener">https://www.slideshare.net/priti_desai/deep-dive-into-keystone-tokens-and-lessons-learned</a></li>
</ul>

      
      
        

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://haystacker.net/keystone-token-function/" data-id="cjwqtuiq4000da5ijsw4fmrk5" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OpenStack/">OpenStack</a></li></ul>


    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/linux-pipe-deep-dive/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older Post</strong>
      <div class="article-nav-title">[徹底解説] Linux パイプのしくみ</div>
    </a>
  
</nav>


  
</article>



</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 id="widget-title-about" class="widget-title">About</h3>
    <div class="widget">
      
        <p><b><font size="3em"> Hayato Otsuka </font></b></p>
      
      
        <p> 東京界隈に出没する仮想化基盤/クラウド系のITエンジニア </p>
      
      
        <p>  </p>
      
      <br />
      
        <p>Twitter: <a href="http://twitter.com/jundo414">@jundo414</a> </p>
      
      
      
        <p>SlideShare: <a href="https://www.slideshare.net/jundo414">@jundo414</a> </p>
      
      
        <p>GitHub: <a href="https://github.com/jundo414">@jundo414</a> </p>
      
      
        <p>Qiita (blog): <a href="https://qiita.com/jundo414">@jundo414</a> </p>
      
      </p>
    </div>
  </div>


  
    

  
    
  <div class="widget-wrap">
    <h3 id="widget-title-tag" class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenStack/">OpenStack</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 id="widget-title-archive" class="widget-title" data-skip-mobile-nav="true">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 id="widget-title-recent-posts" class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/keystone-token-function/">Keystone トークン機能</a>
          </li>
        
          <li>
            <a href="/linux-pipe-deep-dive/">[徹底解説] Linux パイプのしくみ</a>
          </li>
        
          <li>
            <a href="/linux-redirect-deep-dive/">[徹底解説] Linux リダイレクトのしくみ</a>
          </li>
        
          <li>
            <a href="/linux-process-creation-deep-dive/">[徹底解説] Linux プロセス生成のしくみ</a>
          </li>
        
          <li>
            <a href="/howto-use-openstack-api/">OpenStack API 実装例</a>
          </li>
        
      </ul>
    </div>
  </div>


  
</aside>

        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      Copyrights &copy; 2019 Hayato Otsuka All Rights Reserved. <br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>.
      Themed by <a href="https://github.com/kwhrtsk/hexo-theme-ingenuous">Ingenuous</a> (based on <a href="https://github.com/hexojs/hexo-theme-landscape">Landscape</a>).
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>

    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/ja_JP/sdk.js#xfbml=1&version=v2.4";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

<script src="/js/script.js"></script>


  </div>
</body>
</html>
